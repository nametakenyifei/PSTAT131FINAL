---
title: "PSTAT131 Final Project"
author: "Yifei Zhang"
date: '2022-05-11'
output: pdf_document
toc: true
toc_float: true
code_folding: show
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE,
                      warning = FALSE)
```

## Introduction

![](/Users/codenametaken/Downloads/lol.jpg)

### About This Project

|       If you recognize characters from the picture above, you can probably tell we are going to explore the E sport/ video games field in this project. We are looking more specifically into the determining factors for winning a match in a game with  the notoriously toxic gaming community, League of Legends. There are many types of people in this world, and a lot of us fall into two categories, the The League of Legends player category, and the victims of the first category, the player's friend who get forced to watch them playing knowing they are going to lose and even have a temper tantrum afterwards sometimes category. I am a part of the latter group, and to avoid spending extra half an hour watching/playing a game that I know is going to lose, which will lead us to a bad mental state, our friendships on the edge, I want to make a model that can predict the game result as accurately as possible given the first ten minutes game play statistics. Or at least get to know what the most important factors in winning a match are.

### About This Dataset

|     The League of Legends Diamond Ranked Games dataset includes the first ten minutes statistics of approximately ten thousands ranked League of Legends matches (solo queue) ranging from diamond to master ranking. For background information, League of Legends is a multiplayer online battle arena (MOBA) game where there are 3 lanes, a jungle, and 5 player roles each for the 2 teams (blue and red). The first one to take down the enemy Nexus wins the game. 

|       Here is some basic information about the The  League of Legends Diamond Ranked Games dataset. The data is obtained from user MICHELâ€™S FANBOI who seems to have changed their username pretty frequently, on Kaggle, and their source is Riot Games, the developer of League of Legends, API. You can find the dataset following the link here https://www.kaggle.com/datasets/bobbyscience/league-of-legends-diamond-ranked-games-10-min?resource=download. In this dataset there are 9879 observations, and 38 predictors in total.


## Begin tidying

### Loading Packages and Data
```{r}
library(ggplot2)
library(tidyverse)
library(tidymodels)
library(corrplot)
library(ggthemes)
library(discrim)
library(poissonreg)
library(corrr)
library(klaR)
library(ISLR)
library(ISLR2)
library(purrr)
library(janitor)
tidymodels_prefer()
```

```{r}
loldata <- read_csv("DATA/high_diamond_ranked_10min.csv")
```

Before tidying we want to make sure we are not working with a significant amount of missing data. If we do, we want to make sure to tidy the records with significant amount of missing entries out for better accuracy.

```{r }
is.null(loldata)
```
Since we do not have any null entries, wee can directly move on to the next part, normally we would need to deselect some rows or fill in the null with zeros before moving on.

Although from a glance the variable names look pretty unique and not problem causing, we want to use clean the names to avoid potential problems in the future, such as forgetting to capitalize certain letters in the variable name.

```{r}
# save the cleaned data
lol <- clean_names(loldata)

# print the new names
# for later variable selection purpose, also makes life easier
colnames(lol) 
```


Since there are only two teams, Blue and Red, and many of the variables are coded in 1 and 0 that represents either blue or red got it just in the opposite way, a lot of them are repetitive to look at. For example, there are if the entry for our blue_wins is 0, then we know the corresponding entry for red_wins is 1. So we want to deselect some repetitive variables from our data set. It does not matter if blue or red wins, if blue loses then obviously red wins. In this case, we will work on classifying if team blue wins or not.

```{r }
lol_blue <-  lol[ , 0:21]
colnames(lol_blue) # check if we have the right columns
```
For this part please take a look at the Exploratory Data Analysis section first. We want to extract the variables that appears to be significantly correlated with blue_wins.

```{r }
tidy <- lol_blue[c("game_id", "blue_wins", "blue_first_blood", 
                   "blue_kills",  "blue_deaths",
                   "blue_assists","blue_elite_monsters", 
                   "blue_dragons", "blue_total_gold", 
                   "blue_avg_level", "blue_total_experience", 
                   "blue_gold_diff", "blue_experience_diff", 
                   "blue_total_minions_killed", "blue_cs_per_min", 
                   "blue_gold_per_min")]

```


```{r }
tidy

```

## Setting Seed and Data Spliting

The year is 2022 so I am setting the seed to be 2022. It is easy to remember, and it is not too small.

The data is split with a 75% training, 25% testing split. Stratified with blue_wins.


```{r }
set.seed(2022)

lol_split <- lol %>% 
  initial_split(strata = blue_wins, prop = 0.75)
lol_train <- training(lol_split)
lol_test <- testing(lol_split)

dim(lol_train) # check if we have the right proportion

```

## Exploratory Data Analysis

### Check Fairness of Data
From the result we can see there is a very slight difference(insignificant) between the number of blue win and lose

```{r }
lol %>% 
  ggplot(aes(x = blue_wins)) +
  geom_histogram(bins = 3)
```

### Narrow Down Variables

Here we are checking the correlation between all the variables, but we specifically need to pay more attention to what is correlated with blue_wins.

From the result of this auto-plot, we can see there are variables that correlate with blue_wins at about the same scale but in totally opposite ways, which proves our assumption that there are repetitive variables to be correct. 

```{r, fig.height = 10, fig.width = 10 }
lol %>% 
  select(is.numeric) %>% 
  cor(use = "complete.obs") %>% 
  corrplot(type = "lower", diag = FALSE)
```

```{r, fig.height = 10, fig.width = 10 }
lol_blue %>% 
  select(is.numeric) %>% 
  cor(use = "complete.obs") %>% 
  corrplot(type = "lower", diag = FALSE)
```
```{r, fig.height = 10, fig.width = 10 }
tidy %>% 
  select(is.numeric) %>% 
  cor(use = "complete.obs") %>% 
  corrplot(type = "lower", diag = FALSE)
```


```{r }
lol_folds <- vfold_cv(lol_train, v = 5, strata = 'blue_wins')
lol_folds

```

cols = ["gameId", "redFirstBlood", 'redKills', 'redEliteMonsters',
        'redDragons', 'redTotalMinionsKilled', 
        'redTotalJungleMinionsKilled', 'redGoldDiff',
        'redExperienceDiff', 'redCSPerMin', 'redGoldPerMin',
        'redHeralds', 'blueGoldDiff', 'blueExperienceDiff', 
        'blueCSPerMin', 'blueGoldPerMin', 'blueTotalMinionsKilled']



```{r }


```


```{r }


```


```{r }


```


```{r }


```


```{r }


```


```{r }


```


```{r }


```


```{r }


```


```{r }


```


```{r }


```


```{r }


```


```{r }


```


```{r }


```


## Modeling

## Conclusion
